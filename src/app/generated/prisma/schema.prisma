generator client {
  provider = "prisma-client-js"
  output   = "../src/app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Generic enums
enum UserType {
  Super_Admin
  Admin
  User
}

enum SyncStatus {
  PENDING
  SYNCED
  FAILED
}

enum InvoiceStatus {
  DRAFT
  SENT
  PARTIALLY_PAID
  PAID
  CANCELLED
}

enum PaymentMethod {
  BANK_TRANSFER
  CREDIT_CARD
  DEBIT_CARD
  CASH
  CHEQUE
  ONLINE
  OTHER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  EXPIRED
  CANCELED
}

enum packageName {
  Free
  Basic
  Pro
  Enterprise
}

/// Feature enums (kept as-is; arrays used in Package)
enum FreeFeatures {
  Invoicing
  Customer_Management
  Vendor_Management
  Notifications_and_Reminders
  Mobile_Access
  Free_Trials
  Money_Back_Guarantees
}

enum BasicFeatures {
  Inventory_Management
  Payment_Tracking
  Tax_Management
  Reporting_and_Analytics
  Expense_Tracking
  Purchase_Orders
  User_Roles_and_Permissions
  Data_Import_and_Export
  Community_Access
}

enum ProFeatures {
  Multi_Currency_Support
  Recurring_Invoices
  Project_Management
  Time_Tracking
  Integrations
  Custom_Branding
  API_Access
  Dashboards
  Custom_Reports
  Barcoding
  Warehouse_Management
  Shipping_Integration
  E_Commerce_Integration
  CRM_Integration
  Budgeting
  Forecasting
}

enum EnterpriseFeatures {
  Role_Based_Access_Control
  Single_Sign_On
  Two_Factor_Authentication
  Data_Encryption
  Audit_Trails
  Cloud_Backups
  Multi_Language_Support
  Document_Storage
  Compliance_Features
  Advanced_Security_Features
  Dedicated_Account_Manager
  Service_Level_Agreements
  Priority_Support
  White_Labeling
  Custom_Workflows
  Approval_Processes
  Data_Migration_Support
  Performance_Guarantees
  Uptime_Guarantees
}

/// TENANTS
model Tenant {
  id           Int                   @id @default(autoincrement())
  name         String
  slug         String                @unique // friendly unique slug for URL
  // relations
  users        User[]
  packages     Package[]
  vendors      Vendor[]
  customers    Customer[]
  items        Item[]
  invoices     Invoice[]
  payments     Payment[]
  // subscription (current package)
  subscription PackageSubscription[]
  userSession  Session[]
  InvoiceItem  InvoiceItem[]
  // tenant-level settings (JSON)
  settings     Json?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // soft delete

  @@index([name, id])
}

/// USERS
model User {
  id         Int       @id @default(autoincrement())
  tenantId   Int?
  tenant     Tenant?   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name       String
  email      String    @unique // keep global unique â€” change if you want per-tenant uniqueness
  password   String
  role       UserType  @default(User)
  sessions   Session[]
  // optional metadata
  lastSeenAt DateTime?
  locale     String? // e.g. "en", "ur"
  isActive   Boolean   @default(true)

  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  syncStatus SyncStatus @default(PENDING)

  @@index([tenantId, email, id])
}

/// SESSIONS
model Session {
  id           Int      @id @default(autoincrement())
  userId       Int
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenantId     Int
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sessionToken String   @unique
  expires      DateTime
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId, tenantId, id])
}

/// VENDORS
model Vendor {
  id         Int        @id @default(autoincrement())
  tenantId   Int
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name       String
  email      String?
  phone      String?
  address    String?
  taxId      String?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  syncStatus SyncStatus @default(PENDING)

  @@index([tenantId, id, email, phone])
}

/// CUSTOMERS
model Customer {
  id         Int        @id @default(autoincrement())
  tenantId   Int
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name       String
  email      String?
  phone      String?
  address    String?
  invoices   Invoice[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  syncStatus SyncStatus @default(PENDING)

  @@index([tenantId, id])
}

/// ITEMS (inventory)
model Item {
  id           Int           @id @default(autoincrement())
  tenantId     Int
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name         String
  sku          String?
  description  String?
  unitPrice    Decimal       @db.Decimal(12, 2)
  quantity     Decimal       @default(0.0) @db.Decimal(18, 4) // support fractional qty
  invoiceItems InvoiceItem[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  syncStatus   SyncStatus    @default(PENDING)

  @@unique([tenantId, sku]) // SKU unique per tenant (if present)
  @@index([tenantId, id])
}

/// PACKAGES (previously "Packages")
model Package {
  id                 Int                   @id @default(autoincrement())
  name               packageName           @unique @default(Free)
  tenantId           Int
  tenant             Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  price              Decimal               @db.Decimal(12, 2) // precise money
  durationDays       Int // length of subscription in days
  subscription       PackageSubscription[]
  freeFeatures       FreeFeatures[] // Postgres enum arrays supported
  basicFeatures      BasicFeatures[]
  proFeatures        ProFeatures[]
  enterpriseFeatures EnterpriseFeatures[]
  metadata           Json? // free-form (e.g. limits, seats, notes)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([price, tenantId, name])
}

/// PACKAGE SUBSCRIPTIONS (which tenant is on which package)
model PackageSubscription {
  id          Int                @id @default(autoincrement())
  tenantId    Int
  tenant      Tenant             @relation(fields: [tenantId], references: [id])
  packageId   Int
  package     Package            @relation(fields: [packageId], references: [id])
  status      SubscriptionStatus @default(TRIAL)
  seats       Int                @default(1)
  autoRenew   Boolean            @default(true)
  startsAt    DateTime
  endsAt      DateTime
  trialEndsAt DateTime?
  metadata    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([packageId, tenantId])
}

/// INVOICES
model Invoice {
  id            Int           @id @default(autoincrement())
  tenantId      Int
  tenant        Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoiceNumber String // unique per tenant
  invoicePrefix String? // optional prefix
  date          DateTime
  dueDate       DateTime?
  status        InvoiceStatus @default(DRAFT)
  currency      String // ISO code, e.g. "USD"
  currencyRate  Decimal?      @db.Decimal(20, 8) // optional fx rate at issuance
  subtotal      Decimal       @db.Decimal(12, 2)
  tax           Decimal       @default(0.0) @db.Decimal(12, 2)
  total         Decimal       @db.Decimal(12, 2)
  amountPaid    Decimal       @default(0.0) @db.Decimal(12, 2)
  balanceDue    Decimal       @db.Decimal(12, 2)
  note          String?
  customerId    Int
  customer      Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  items         InvoiceItem[]
  payments      Payment[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  syncStatus    SyncStatus    @default(PENDING)

  @@unique([invoiceNumber, tenantId])
  @@index([tenantId])
  @@index([date])
}

/// INVOICE ITEMS (line items)
model InvoiceItem {
  id          Int        @id @default(autoincrement())
  tenantId    Int
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoiceId   Int
  invoice     Invoice    @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  itemId      Int
  item        Item       @relation(fields: [itemId], references: [id], onDelete: Cascade)
  description String?
  quantity    Decimal    @db.Decimal(18, 4)
  unitPrice   Decimal    @db.Decimal(12, 2)
  lineTotal   Decimal    @db.Decimal(12, 2)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  syncStatus  SyncStatus @default(PENDING)

  @@index([tenantId])
  @@index([invoiceId])
}

/// PAYMENTS
model Payment {
  id         Int           @id @default(autoincrement())
  tenantId   Int
  tenant     Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invoiceId  Int
  invoice    Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  date       DateTime
  paidDate   DateTime
  amount     Decimal       @db.Decimal(12, 2)
  method     PaymentMethod
  status     PaymentStatus @default(COMPLETED)
  reference  String? // gateway transaction id, check number etc.
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  syncStatus SyncStatus    @default(PENDING)

  @@index([tenantId])
  @@index([invoiceId])
  @@index([reference])
}

/// AUDIT LOG (for security / admin tracking)
model AuditLog {
  id        Int      @id @default(autoincrement())
  tenantId  Int?
  userId    Int?
  actor     String? // e.g. "system", "user:123"
  action    String // e.g. "invoice.create", "user.login"
  meta      Json? // arbitrary metadata
  ipAddress String?
  createdAt DateTime @default(now())

  @@index([tenantId])
  @@index([userId])
  @@index([action])
}
